# SPDX-FileCopyrightText: 2002-2025 Lawrence Livermore National Laboratory & other contributors to SLURM <https://github.com/SchedMD/slurm/commits/master/DISCLAIMER>
# SPDX-License-Identifier: GPL-2.0-or-later
# SPDX-PackageName: slurm-containers

diff --git a/src/slurmctld/agent.c b/src/slurmctld/agent.c
index 3887a38cde..101589fa6e 100644
--- a/src/slurmctld/agent.c
+++ b/src/slurmctld/agent.c
@@ -1534,11 +1534,13 @@ static void *_agent_nodes_update(void *arg)
 			break;
 		}

-		if (!list_count(update_node_list))
-			continue;
-		lock_slurmctld(node_write_lock);
-		list_delete_all(update_node_list, _foreach_node_did_resp, NULL);
-		unlock_slurmctld(node_write_lock);
+		if (list_count(update_node_list)) {
+			lock_slurmctld(node_write_lock);
+			list_delete_all(update_node_list,
+					_foreach_node_did_resp, NULL);
+			unlock_slurmctld(node_write_lock);
+		}
+		ping_nodes_update();
 	}

 	return NULL;
diff --git a/src/slurmctld/ping_nodes.c b/src/slurmctld/ping_nodes.c
index fe615e893e..91922bedb7 100644
--- a/src/slurmctld/ping_nodes.c
+++ b/src/slurmctld/ping_nodes.c
@@ -60,6 +60,7 @@
 #define PING_TIMEOUT 100

 static pthread_mutex_t lock_mutex = PTHREAD_MUTEX_INITIALIZER;
+static bool ping_updated = false;
 static int ping_count = 0;
 static time_t ping_start = 0;

@@ -83,8 +84,17 @@ bool is_ping_done (void)
 			      PING_TIMEOUT);
 			ping_msg_sent = true;
 		}
-	} else
+	} else {
 		ping_msg_sent = false;
+		/*
+		 * We can only consider the last node ping cycle to be fully
+		 * completed if ping_updated is true, meaning the
+		 * _agent_nodes_update thread finished updating the nodes
+		 * response. Otherwise, we could hit a race and incorrectly set
+		 * responding/healthy nodes to DOWN.
+		 */
+		is_done = ping_updated;
+	}
 	slurm_mutex_unlock(&lock_mutex);

 	return is_done;
@@ -104,6 +114,18 @@ void ping_begin (void)
 	slurm_mutex_unlock(&lock_mutex);
 }

+/*
+ * ping_nodes_update - A ping cycle can end but the update can still be pending
+ * for the _agent_nodes_update thread. This call will confirm node info was
+ * updated.
+ */
+void ping_nodes_update(void)
+{
+	slurm_mutex_lock(&lock_mutex);
+	ping_updated = true;
+	slurm_mutex_unlock(&lock_mutex);
+}
+
 /*
  * ping_end - record that a ping cycle has ended. This can be called more
  *	than once (for REQUEST_PING and simultaneous REQUEST_NODE_REGISTRATION
@@ -121,7 +143,7 @@ void ping_end (void)

 	if (ping_count == 0) /* no more running ping cycles */
 		ping_start = 0;
-
+	ping_updated = false;
 	slurm_mutex_unlock(&lock_mutex);
 }

diff --git a/src/slurmctld/ping_nodes.h b/src/slurmctld/ping_nodes.h
index 05ada67128..8f87db329e 100644
--- a/src/slurmctld/ping_nodes.h
+++ b/src/slurmctld/ping_nodes.h
@@ -57,6 +57,13 @@ extern bool is_ping_done (void);
  */
 extern void ping_begin (void);

+/*
+ * ping_nodes_update - A ping cycle can end but the update can still be pending
+ * for the _agent_nodes_update thread. This call will confirm node info was
+ * updated.
+ */
+extern void ping_nodes_update(void);
+
 /*
  * ping_end - record that a ping cycle has ended. This can be called more
  *	than once (for REQUEST_PING and simultaneous REQUEST_NODE_REGISTRATION
