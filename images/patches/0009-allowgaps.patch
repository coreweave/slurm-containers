diff --git a/doc/man/man5/topology.conf.5 b/doc/man/man5/topology.conf.5
index b826538624..9bc353f3aa 100644
--- a/doc/man/man5/topology.conf.5
+++ b/doc/man/man5/topology.conf.5
@@ -102,7 +102,8 @@ This field must be specified.
 .TP
 \fBNodes\fR
 Child Nodes of the named block.
-This must be specified along with the \fBBlockName\fR.
+This must be specified along with the \fBBlockName\fR otherwise,
+\fBfBAllowGaps\fR need to be set.
 .IP

 .TP
@@ -113,6 +114,13 @@ Each block must have at least the planning base block size count of nodes.
 Successive BlockSizes must be a power of two larger than the prior values.
 .IP

+.TP
+\fBAllowGaps\fR=\fI<yes|no>\fR
+Allow blocks to have fewer nodes than the minimum \fBBlockSizes\fR.
+.sp
+Default is "no".
+.IP
+
 .SH "EXAMPLE"
 .nf
 ##################################################################
diff --git a/src/plugins/topology/block/block_record.c b/src/plugins/topology/block/block_record.c
index 050b4716de..34217a1f8f 100644
--- a/src/plugins/topology/block/block_record.c
+++ b/src/plugins/topology/block/block_record.c
@@ -52,6 +52,7 @@ uint16_t block_sizes_cnt = 0;
 uint32_t blocks_nodes_cnt = 0;
 int block_record_cnt = 0;
 int ablock_record_cnt = 0;
+static bool allow_gaps = false;

 static s_p_hashtbl_t *conf_hashtbl = NULL;

@@ -85,13 +86,6 @@ static int _parse_block(void **dest, slurm_parser_enum_t type,
 	s_p_get_string(&b->nodes, "Nodes", tbl);
 	s_p_hashtbl_destroy(tbl);

-	if (!b->nodes) {
-		error("block %s hasn't got nodes",
-		      b->block_name);
-		_destroy_block(b);
-		return -1;
-	}
-
 	*dest = (void *)b;

 	return 1;
@@ -101,6 +95,7 @@ static int _parse_block(void **dest, slurm_parser_enum_t type,
 static int _read_topo_file(slurm_conf_block_t **ptr_array[])
 {
 	static s_p_options_t block_options[] = {
+		{"AllowGaps", S_P_BOOLEAN},
 		{"BlockName", S_P_ARRAY, _parse_block, _destroy_block},
 		{"BlockSizes", S_P_STRING},
 		{NULL}
@@ -120,6 +115,8 @@ static int _read_topo_file(slurm_conf_block_t **ptr_array[])
 		      topo_conf);
 	}

+	s_p_get_boolean(&allow_gaps, "AllowGaps", conf_hashtbl);
+
 	FREE_NULL_BITMAP(block_levels);
 	block_levels = bit_alloc(MAX_BLOCK_LEVELS);

@@ -274,11 +271,15 @@ extern void block_record_validate(void)
 			if (bblock_node_cnt == 0) {
 				bblock_node_cnt =
 					bit_set_count(block_ptr->node_bitmap);
-			} else if (bit_set_count(block_ptr->node_bitmap) <
-				   bblock_node_cnt) {
+			} else if (!allow_gaps &&
+				   (bit_set_count(block_ptr->node_bitmap) <
+				    bblock_node_cnt)) {
 				fatal("Block configuration (%s) children count lower than bblock_node_cnt",
 				      ptr->block_name);
 			}
+
+		} else if (allow_gaps) {
+			block_ptr->node_bitmap = bit_alloc(node_record_count);
 		} else {
 			fatal("Block configuration (%s) lacks children",
 			      ptr->block_name);
@@ -298,6 +299,9 @@ extern void block_record_validate(void)
 			xfree(tmp_nodes);
 			FREE_NULL_BITMAP(tmp_bitmap);
 		}
+	} else if (allow_gaps) {
+		blocks_nodes_bitmap = bit_alloc(node_record_count);
+		warning("Blocks do not contain any nodes");
 	} else
 		fatal("blocks contain no nodes");

